// src/features/auth/auth.repository.js
const prisma = require('../../config/db');
const userProfileRepository = require('../user_profile/user_profile.repository');
const { ConflictError, NotFoundError } = require('../../common/errors');

/**
 * Finds a user by their email address.
 * @param {string} email - The email address of the user.
 * @returns {Promise<object|null>} The user object if found, otherwise null.
 * @throws {Error} If a database error occurs.
 */
async function findUserByEmail(email) {
  try {
    return await prisma.User.findUnique({
      where: { email },
      include: { 
        user_profiles: true // This is optional (?) in schema, so it might be null
      }
    });
  } catch (err) {
    console.error('AuthRepository.findUserByEmail:', err.message);
    throw new Error('Database error during user lookup.');
  }
}

/**
 * Creates a new user and their associated profile.
 * @param {object} userData - The data for the new user.
 * @returns {Promise<object>} The newly created user object with their profile.
 * @throws {Error} If a database error occurs or if the email/username already exists.
 */
async function createUser(userData) {
  try {
    // Create user first
    const user = await prisma.User.create({
      data: {
        email: userData.email,
        password_hash: userData.password_hash,
        username: userData.username,
        role: userData.role || 'user', // Default role as per schema enum
        // created_at and updated_at are auto-generated by schema
        // is_deleted defaults to false as per schema
      }
    });
    
    // Create associated user profile with schema-aligned defaults
    const user_profile = await userProfileRepository.createProfile(user.user_id, {
      // All these fields are optional in schema and can be null
      date_of_birth: null,
      height_cm: null,
      weight_kg: null,
      profile_picture_url: null,
      allergies: [], // Empty array as default
      dietary_preferences: [], // Empty array as default
      primary_fitness_goal: null,
      gender: null,
      // created_at, updated_at, is_deleted are auto-generated/defaulted
    });
    
    return {
      ...user,
      user_profiles: user_profile // Include the created profile
    };
  } catch (err) {
    console.error('AuthRepository.createUser:', err.message);
    
    // Handle Prisma unique constraint violations
    if (err.code === 'P2002') {
      let target = '';
      if (err.meta && err.meta.target) {
        target = Array.isArray(err.meta.target) ? err.meta.target.join(', ') : String(err.meta.target);
      }
      if (target.includes('email')) {
        throw new ConflictError('User with this email already exists.');
      } else if (target.includes('username')) {
        throw new ConflictError('Username already taken.');
      }
    }
    throw new Error('Database error during user creation.');
  }
}

/**
 * Finds a user by their ID.
 * @param {number} userId - The ID of the user.
 * @returns {Promise<object|null>} The user object if found, otherwise null.
 * @throws {Error} If a database error occurs.
 */
async function findUserById(userId) {
  try {
    return await prisma.User.findUnique({
      where: { user_id: userId },
      include: { 
        user_profiles: true
      }
    });
  } catch (err) {
    console.error('AuthRepository.findUserById:', err.message);
    throw new Error('Database error during user lookup.');
  }
}

/**
 * Updates user password.
 * @param {number} userId - The ID of the user.
 * @param {string} passwordHash - New password hash.
 * @returns {Promise<object>} Updated user object.
 * @throws {Error} If a database error occurs.
 */
async function updateUserPassword(userId, passwordHash) {
  try {
    return await prisma.User.update({
      where: { user_id: userId },
      data: { 
        password_hash: passwordHash,
        updated_at: new Date()
      }
    });
  } catch (err) {
    console.error('AuthRepository.updateUserPassword:', err.message);
    throw new Error('Database error during password update.');
  }
}

/**
 * Creates password reset token.
 * @param {object} tokenData - Token data including userId, token, expiresAt.
 * @returns {Promise<object>} Created token record.
 * @throws {Error} If a database error occurs.
 */
async function createPasswordResetToken(tokenData) {
  try {
    return await prisma.password_reset_tokens.create({
      data: {
        user_id: tokenData.userId,
        token: tokenData.token,
        expires_at: tokenData.expiresAt,
        created_at: new Date()
      }
    });
  } catch (err) {
    console.error('AuthRepository.createPasswordResetToken:', err);
    throw new Error('Database error during password reset token creation.');
  }
}

/**
 * Finds password reset token.
 * @param {string} token - Reset token.
 * @returns {Promise<object|null>} Token record if found, otherwise null.
 * @throws {Error} If a database error occurs.
 */
async function findPasswordResetToken(token) {
  try {
    return await prisma.password_reset_tokens.findUnique({
      where: { token }
    });
  } catch (err) {
    console.error('AuthRepository.findPasswordResetToken:', err);
    throw new Error('Database error during password reset token lookup.');
  }
}

/**
 * Deletes password reset token.
 * @param {string} token - Reset token.
 * @returns {Promise<object>} Deleted token record.
 * @throws {Error} If a database error occurs.
 */
async function deletePasswordResetToken(token) {
  try {
    return await prisma.password_reset_tokens.delete({
      where: { token }
    });
  } catch (err) {
    console.error('AuthRepository.deletePasswordResetToken:', err);
    throw new Error('Database error during password reset token deletion.');
  }
}

/**
 * Creates refresh token.
 * @param {object} tokenData - Token data including userId, token, expiresAt.
 * @returns {Promise<object>} Created token record.
 * @throws {Error} If a database error occurs.
 */
async function createRefreshToken(tokenData) {
  try {
    return await prisma.refresh_tokens.create({
      data: {
        user_id: tokenData.userId,
        token: tokenData.token,
        expires_at: tokenData.expiresAt,
        created_at: new Date()
      }
    });
  } catch (err) {
    console.error('AuthRepository.createRefreshToken:', err);
    throw new Error('Database error during refresh token creation.');
  }
}

/**
 * Finds refresh token.
 * @param {string} token - Refresh token.
 * @returns {Promise<object|null>} Token record if found, otherwise null.
 * @throws {Error} If a database error occurs.
 */
async function findRefreshToken(token) {
  try {
    return await prisma.refresh_tokens.findUnique({
      where: { token }
    });
  } catch (err) {
    console.error('AuthRepository.findRefreshToken:', err);
    throw new Error('Database error during refresh token lookup.');
  }
}

/**
 * Deletes refresh token.
 * @param {string} token - Refresh token.
 * @returns {Promise<object>} Deleted token record.
 * @throws {Error} If a database error occurs.
 */
async function deleteRefreshToken(token) {
  try {
    return await prisma.refresh_tokens.delete({
      where: { token }
    });
  } catch (err) {
    console.error('AuthRepository.deleteRefreshToken:', err);
    throw new Error('Database error during refresh token deletion.');
  }
}

module.exports = {
  findUserByEmail,
  createUser,
  findUserById,
  updateUserPassword,
  createPasswordResetToken,
  findPasswordResetToken,
  deletePasswordResetToken,
  createRefreshToken,
  findRefreshToken,
  deleteRefreshToken
};